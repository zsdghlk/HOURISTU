import { parseLawXml } from "@/lib/parseLawXml";
import { formatParagraphNum, formatArticleHeading } from "../../../utils/lawFormat";
import { ROKUPO } from "@/lib/rokupo";

type Art = {
  number?: string;
  key: string;
  paragraphs: { num?: string; text: string }[];
  /** e-Gov 側で付くことがある（附則ラベルなど） */
  prefix?: string;
};

async function fetchXml(lawId: string): Promise<string> {
  const res = await fetch(`https://laws.e-gov.go.jp/api/1/lawdata/${lawId}`, { cache: "no-store" });
  if (!res.ok) throw new Error(`Failed to fetch XML: ${res.status}`);
  return res.text();
}

function highlight(text: string, q: string) {
  if (!q) return text;
  try {
    const re = new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi");
    return text.split(re).reduce<JSX.Element[]>((acc, part, i, arr) => {
      acc.push(<span key={`p${i}`}>{part}</span>);
      if (i < arr.length - 1) acc.push(<mark key={`m${i}`}>{q}</mark>);
      return acc;
    }, []);
  } catch {
    return text;
  }
}

/** 連続区間の prefix（附則など）を継承して各条に _prefix を付与 */
function computeArtsWithPrefix(arts: Art[]): (Art & { _prefix?: string })[] {
  let lastPrefix = "";
  return (arts || []).map((a) => {
    const keyStr = String(a?.key ?? "");

    // 1) 明示の prefix（優先）
    if (a?.prefix && a.prefix.trim()) {
      lastPrefix = a.prefix.trim();
    }
    // 2) 見出しの key が「附則…」なら附則に切替
    else if (/^附則/.test(keyStr)) {
      lastPrefix = "附則";
    }
    // 3) それ以外は lastPrefix を継承
    return { ...a, _prefix: lastPrefix };
  });
}

export default async function LawDetail(props: {
  params: Promise<{ lawId: string }>;
  searchParams: Promise<{ q?: string }>;
}) {
  const { lawId } = await props.params;
  const { q: rawQ } = await props.searchParams;
  const q = (rawQ ?? "").trim();

  // XML → パース
  const xml = await fetchXml(lawId);
  const parsed = await parseLawXml(xml);

  // タイトル
  const fallback = ROKUPO.find((x) => x.lawId === lawId)?.title;
  const pageTitle = parsed.lawTitle || fallback || "法令";

  // フィルタ
  let arts: Art[] = (parsed.articles as any) ?? [];
/* FILTER OFF for debug */

  // ---- 附則などの prefix を継承して付与（JSX の外でやること！）----
  const artsWithPrefix = computeArtsWithPrefix(arts);

  console.log("DBG first5", (artsWithPrefix||[]).slice(0,5).map(x=>({key:x.key, num:x.number, prefix:x.prefix, _prefix:x._prefix})));console.log("DBG first5", (artsWithPrefix||[]).slice(0,5).map(x=>({key:x.key, num:x.number, prefix:x.prefix, _prefix:x._prefix})));console.log("DBG first5", (artsWithPrefix||[]).slice(0,5).map(x=>({key:x.key, num:x.number, prefix:x.prefix, _prefix:x._prefix})));// 空ならメッセージを返して終了（これも JSX の手前で！）
  if (!Array.isArray(artsWithPrefix) || artsWithPrefix.length === 0) {
    return (
      <div style={{ padding: 16 }}>
        <h1 style={{ fontSize: 20, marginBottom: 12 }}>{pageTitle}</h1>
        <div>条文が見つかりませんでした。</div>
      </div>
    );
  }

  // 表示
  return (
    <div style={{ padding: 16 }}>
      <h1 style={{ fontSize: 20, marginBottom: 12 }}>{pageTitle}</h1>

      <div style={{ display: "grid", gap: 12 }}>
        {artsWithPrefix.map((a, idxA) => {
          // 見出し = 「(prefix) 第n条」 例: 「附則 第一条」
          const prefixLabel =
            a._prefix && /附則/.test(String(a._prefix)) ? "附則 " : "";
          const heading = `${prefixLabel}${formatArticleHeading(a.number ?? a.key)}`;
          const ukey = `${a.key}-${idxA}`;

          return (
            <section key={ukey} className="card">
              <h2 style={{ marginBottom: 8 }}>{heading}</h2>
              <div style={{ display: "grid", gap: 10 }}>
                {(a.paragraphs || []).map((p, i) => (
                  <p key={`${ukey}-p${i}`}>
                    {formatParagraphNum(p?.num as any, i)}
                    {highlight(p.text || "", q)}
                  </p>
                ))}
              </div>
            </section>
          );
        })}
      </div>

      {/* 既存の strong を非表示にする（もし formatParagraphNum が <strong> を返す場合の保険） */}
      <style>
        {`strong { display: none; } mark { background: #fff0a6; padding: 0 .15em; }`}
      </style>
    </div>
  );
}
