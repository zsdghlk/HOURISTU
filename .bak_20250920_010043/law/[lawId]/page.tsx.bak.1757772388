import { parseLawXml } from "@/lib/parseLawXml";
import { formatParagraphNum, formatArticleHeading } from "../../../utils/lawFormat";
import { ROKUPO } from "@/lib/rokupo";

type Art = {
  number?: string;
  key: string;
  paragraphs: { num?: string; text: string }[];
  /** e-Gov パース時に入ってくる（附則ラベルなど） */
  prefix?: string;
};

// e-Gov から XML 取得（SSR 内）
async function fetchXml(lawId: string): Promise<string> {
  const res = await fetch(`https://laws.e-gov.go.jp/api/1/lawdata/${lawId}`, { cache: "no-store" });
  if (!res.ok) throw new Error(`Failed to fetch XML: ${res.status}`);
  return res.text();
}

function highlight(text: string, q: string) {
  if (!q) return text;
  try {
    const re = new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "gi");
    return text.split(re).reduce<JSX.Element[]>((acc, part, i, arr) => {
      acc.push(<span key={`p${i}`}>{part}</span>);
      if (i < arr.length - 1) acc.push(<mark key={`m${i}`}>{q}</mark>);
      return acc;
    }, []);
  } catch {
    return text;
  }
}

/** 連続区間の prefix（附則など）を継承して各条に _prefix を付与 */
function computeArtsWithPrefix(arts: Art[]): (Art & { _prefix?: string })[] {
  let lastPrefix = "";
  return (arts || []).map((a) => {
    const keyStr = String(a?.key ?? "");
    if (a?.prefix && a.prefix.trim()) {
      lastPrefix = a.prefix.trim();
    } else if (/^附則/.test(keyStr)) {
      // 「附則」「附則 第一条」など key からも附則を検知
      lastPrefix = "附則";
    }
    return { ...a, _prefix: lastPrefix };
  });
}

export default async function LawDetail(props: {
  params: Promise<{ lawId: string }>;
  searchParams: Promise<{ q?: string }>;
}) {
  const { lawId } = await props.params;
  const { q: rawQ } = await props.searchParams;
  const q = (rawQ ?? "").trim();

  // XML → パース
  const xml = await fetchXml(lawId);
  const parsed: any = await parseLawXml(xml);

  // タイトル
  const fallback = ROKUPO.find((x) => x.lawId === lawId)?.title;
  const pageTitle = parsed?.lawTitle || fallback || "法令";

  // ソース配列を安全に取り出し
  let arts: Art[] = Array.isArray(parsed?.articles) ? (parsed.articles as Art[]) : [];

  // クエリがあれば絞り込み（※後から戻せます）
  if (q) {
    arts = arts.filter(
      (a) =>
        (a.number ?? "").includes(q) ||
        (a.paragraphs || []).some((p) => (p.text || "").includes(q))
    );
  }

  // ---- 附則などの prefix を継承して付与（JSX の外で実行）----
  const artsWithPrefix = computeArtsWithPrefix(arts);

  // 0件なら JSX の外で早期 return（ここが JSX 内だと「Expression expected」で落ちます）
  if (!Array.isArray(artsWithPrefix) || artsWithPrefix.length === 0) {
    return (
      <div style={{ padding: 16 }}>
        <h1 style={{ fontSize: 20, marginBottom: 12 }}>{pageTitle}</h1>
        <div>条文が見つかりませんでした。</div>
      </div>
    );
  }

  return (
    <div style={{ padding: 16 }}>
      <h1 style={{ fontSize: 20, marginBottom: 12 }}>{pageTitle}</h1>

      <div style={{ display: "grid", gap: 12 }}>
        {artsWithPrefix.map((a, idxA) => {
          // 見出し = 「(prefix) 第n条」 例: 「附則 第一条」
          const prefixLabel = a._prefix && /附則/.test(String(a._prefix)) ? "附則 " : "";
          const heading = `${prefixLabel}${formatArticleHeading(a.number ?? a.key)}`;
          const ukey = `${a.key}-${idxA}`;

          return (
            <section key={ukey} className="card">
              <h2 style={{ marginBottom: 8 }}>{heading}</h2>
              <div style={{ display: "grid", gap: 10 }}>
                {(a.paragraphs || []).map((p, i) => (
                  <p key={`${ukey}-p${i}`}>
                    {formatParagraphNum(p?.num as any, i)}
                    {highlight(p.text || "", q)}
                  </p>
                ))}
              </div>
            </section>
          );
        })}
      </div>
    </div>
  );
}
